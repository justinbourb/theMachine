<html>
  <head>
    <script src="js/countUp.js"></script>
    <script src="js/theMachine.js"></script>
    <script src="js/collapse.js"></script>
    <script src="https://justinbourb.github.io/jstinytest_dom_edition/tinytest_dom_edition.js"></script>
  </head>
  <div id="heatCountUpAnimManual" data-resource="heat"></div>
  <div id="heatManual" data-resource="heat"></div>
  <div id="testingContainer" style="margin-left: -9999px">
    <div id="heatCountUpAnim" data-resource="heat" ></div>
    <div id="heatItemCap" data-resource="heat">Item Cap: default cap</div>
    <div id="heatProductionTime" data-resource="heat">Production Time: default time</div>
    <div id="heatProductionVolume" data-resource="heat">Production Volume: default volume</div>
    <div id="heatWorkerCap" data-resource="heat">Worker Cap: default cap</div>
    <div id="heatAutomationRate" data-resource="heat">Automation Rate: default rate</div>
    <div id="heatWorkerEfficiency" data-resource="heat">Worker Efficiency: default efficiency</div>
    <div id="heatRate" data-resource="heat"></div>
    <div id="heatTime" data-resource="heat"></div>
  </div>  
</html>

<script>

  //make a backup of any user data
  let theMachineBackup = theMachine.store('theMachine');
  //reset conditions to test values
  conditions = (
      {
        heat: { counterElement: "", counterElementManual: "", duration: "", efficiency: 25.12, endValue: 10, gradientColors: ["white", "#F5F5F5"], paused: false, ratePerSecond: 0.5, rateCost: 6, startValue: 0, wasPageLeft: false, workersAssigned: 0, workerCap: 0 },
        tanks: {}
      }); 
  //store "test" conditions" in local storage for testing purposes
  theMachine.store('theMachine', conditions);
    
  tests({
    '1) theMachine.calculateValues("init") should fill in calculated values for conditions':function() {       
      theMachine.calculateValues('init');
      eq(conditions.heat.counterElement, document.getElementById("heatCountUpAnim"));
      eq(conditions.heat.counterElementManual, document.getElementById("heatCountUpAnimManual"));
      eq(conditions.heat.duration, 20);
    },
    
    '2) theMachine.checkStartValue() should update start value as needed':function() {
      //theMachine.init();
      conditions.heat.heatCountUpAnim = {};
      conditions.heat.heatCountUpAnim.frameVal = 8;
      conditions.heat.startValue = 7;
      theMachine.checkStartValue("heat", "heatCountUpAnim");
      eq(conditions.heat.startValue, 8);
    },
    
    '3) theMachine.manualCounterButtonStatus() should toggle disabled state correctly':function() {
      conditions.heat.startValue = 7;
      conditions.heat.heatCountUpAnim.frameVal = 7;
      conditions.heat.endValue = 10;
      theMachine.manualCounterButtonStatus('heat', 'heatCountUpAnim')
      eq(document.getElementById('heat' + 'Manual').disabled, false);
      conditions.heat.startValue = 10;
      theMachine.manualCounterButtonStatus('heat', 'heatCountUpAnim')
      eq(document.getElementById('heat' + 'Manual').disabled, true);
    },
    
    '4) theMachine.store() should store in local storage':function() {
      theMachine.store('test', 1);
      eq(theMachine.store('test'), 1);
    },
    
    '5) theMachine.updateCounter() "Item Capacity" should only update endValue when not paused':function() {
      let testCase = {target: {dataset: {resource: "heat"}, innerHTML: 'Item Capacity'}};
      conditions.heat.endValue = 10;
      try{
        theMachine.updateCounter(testCase);
      } catch (e) {};
      
      //condition which should change
      eq(conditions.heat.endValue, 20);
      
      //it should not affect other values
      eq(conditions.heat.counterElement, document.getElementById('heatCountUpAnim'));
      eq(conditions.heat.counterElementManual, document.getElementById('heatCountUpAnimManual'));
      eq(conditions.heat.duration, 20);
      eq(conditions.heat.gradientColors[0], "white");
      eq(conditions.heat.gradientColors[1], "#F5F5F5");
      eq(conditions.heat.paused, false);
      eq(conditions.heat.ratePerSecond, 0.5);
      eq(conditions.heat.rateCost, 6);
      eq(conditions.heat.startValue, 10);
      eq(conditions.heat.heatCountUpAnim.options.suffix, ' / 20');
      
    },
    
    '6) theMachine.updateCounter() "Item Capacity" should only update options.suffix, Item Cap and endVal when paused':function() {
      let testCase = {target: {dataset: {resource: "heat"}, innerHTML: 'Item Capacity'}};      
     
      conditions.heat.paused = true;
      conditions.heat.heatCountUpAnim.endVal = 5;
      conditions.heat.heatCountUpAnim.options.suffix = ' / 10'
      
      try{
        theMachine.updateCounter(testCase);
      } catch (e) {};
      
      //conditions which should change
      eq(document.getElementById('heatCountUpAnim').innerHTML, '10 / 20');
      
      //it should not affect other values
      eq(conditions.heat.counterElement, document.getElementById('heatCountUpAnim'));
      eq(conditions.heat.counterElementManual, document.getElementById('heatCountUpAnimManual'));
      eq(conditions.heat.duration, 40);
      eq(conditions.heat.gradientColors[0], "white");
      eq(conditions.heat.gradientColors[1], "#F5F5F5");
      eq(conditions.heat.paused, true);
      eq(conditions.heat.ratePerSecond, 0.5);
      eq(conditions.heat.rateCost, 6);
      eq(conditions.heat.startValue, 10);
      
    },
    
    '7) theMachine.updateCounter() "Job Speed" should only update ratePerSecond, startValue and rateCost':function () {
      let testCase = {target: {dataset: {resource: "heat"}, innerHTML: 'Job Speed'}};   
      conditions.heat.paused = false;
       try{
        theMachine.updateCounter(testCase);
      } catch (e) {};
      
      //conditions which should change
      eq(conditions.heat.ratePerSecond, 0.55);
      eq(conditions.heat.rateCost, 6.6);
      eq(conditions.heat.startValue, 4);
      
      //it should not affect other values
      eq(document.getElementById('heatCountUpAnim').innerHTML, '4 / 30');
      eq(conditions.heat.counterElement, document.getElementById('heatCountUpAnim'));
      eq(conditions.heat.counterElementManual, document.getElementById('heatCountUpAnimManual'));
      eq(conditions.heat.duration, 47.272727272727266);
      eq(conditions.heat.gradientColors[0], "white");
      eq(conditions.heat.gradientColors[1], "#F5F5F5");
      eq(conditions.heat.paused, false);
      
    },
      //conditions[resource][countUpNameAuto].options.ratePerSecond = conditions[resource].ratePerSecond;
    '8) theMachine.updateCounter() "Job Speed" should update correctly while paused':function () {
      let testCase = {target: {dataset: {resource: "heat"}, innerHTML: 'Job Speed'}};   
      conditions.heat.paused = true;
       try{
        theMachine.updateCounter(testCase);
      } catch (e) {};

      //conditions which should change
      eq(conditions.heat.ratePerSecond, 0.55);
      eq(conditions.heat.rateCost, 6.6);
      eq(conditions.heat.startValue, 4);

      //it should not affect other values
      eq(conditions.heat.counterElement, document.getElementById('heatCountUpAnim'));
      eq(conditions.heat.counterElementManual, document.getElementById('heatCountUpAnimManual'));
      eq(conditions.heat.duration, 47.272727272727266);
      eq(conditions.heat.gradientColors[0], "white");
      eq(conditions.heat.gradientColors[1], "#F5F5F5");
      eq(conditions.heat.paused, true);

    },
    
    '9) theMachine.calculateValues("init") updates startValue based on time passed':function() {
      conditions.heat.wasPageLeft = Date.now() - 10000;
      conditions.heat.paused = false;
      let oldStartValue = conditions.heat.startValue;
      theMachine.calculateValues('init');
      eq(conditions.heat.startValue, oldStartValue+5.5);
    },
    
  });
  //restore user data after tests are compeleted
  theMachine.store('theMachine', theMachineBackup);
</script>